## Исходные коды приложения

Тут js написанный самими, а не стороний как в scripts.

#### Шаблон для *.js
Поскольку мы мало понимаем во фронтэнде, а от утиной типизации нас трясет, то для того чтоб не испортить,
 что то объявленное глобально, свой код на js оборачиваем в неименованные функции, которые тут-же вызываем,
 и требуем от себя писать код по строгим правилам (инструкция `'use strict';`). 

```js
(function () {
    'use strict';
 
    //Код здесь
 
})(); 
```

#### Шаблон для элемента `<script>` файлов *.vue
Можно ли, а если можно то как, импортировать зависимости в компонентах, при данном подходе к созданию приложения,
 я не знаю. Так что сначала импортируем при помощи RequireJS или require-vuejs (с префиксом `vue!`) обычные js или Vue
 компоненты соответсвенно. Стоит ли оборочивать содержимое компонента неименованной функцией, думаю нет, может ошибаюсь.
 `'use strict';` так же не пишу, может зря.
 
Первый аргумент функции `define` - массив имен компонентов пишим в первой строке, второй аргумент функцию, в 
 которую будут переданны запрошенные модули во второй, хоть какая то надежда не запутатся при добавлении/удалении
 аргументов. 

```js
define(["Vue", "vue!Foo", "vue!Bar"],
    function (Vue, Foo, Bar) {
        return {};//возвращает что то полезное, к примеру результат `Vue.component("Foo", {...});`
    }
);
```

#### main.js
Назначение надеюсь ясно из названия, именно его загрузит первым RequireJS, так как он задан в атрибуте
`data-main`, с него начнется выполнения клиентсой части нашего приложения.

```html
<script data-main="app/main" src="scripts/require/2.3.6/require.js"></script>
```

Подгружает css, и сконфигурировав RequireJS с помощью config.js, запускает app.js

#### config.js
Отвечает за конфигурирование RequireJS, строчками типа:
```js
requirejs.config({"paths": {"Vue": '/scripts/vue/2.6.10/vue'}});
```

#### app.js
Создает экземпляр Vue - приложение

####  App.vue
Основной компонент нашего одностраничного приложения. Содержи навигацию `<b-navbar></b-navbar>`, хлебные крошки
 `<b-breadcrumb :items="breadcrumb"></b-breadcrumb> `и контейнер для других компонентов настроенных через
  Router.vue `<router-view></router-view>`

По информации из Router.vue пытается правильно построить хлебные крошки

####  Router.vue
Компонент в котором настраивается роутинг. Возможно более экономно использовать не vue компонент, а старый, добрый js,
 но `const` или `let` вместо `var` радуют мой глаз, а я продолжаю не понимать почему тут так работает. Может дело в
 chrome...
 
Для ленивой загрузки модулей, только когда они реально потребуются - используем следущую функцию:
```js
const asyncComp = function (componentName) {
    return function (resolve) {
        require([componentName], resolve);
    };
};

const routes = [
    {
        path: '/',
        component: asyncComp("vue!Home")
    }
]
```
Добавленна простейшая поддержка хлебных крошек, добавь подсказку для них в свойстве `meta` и код в App.vue постарается 
 их правильно отобразить. В большом приложении все станет сложней, так как некоторые значения придется вычислять,
 но пока так.
```js
const routes = [{
    path: '/foo',
    component: asyncComp("vue!Foo"),
    meta: {
        breadcrumb: "Фуу"
    }
}];
```
С помощью `menuItem: "Фуууууу"` в `meta: {}` для корневых элементов можно задать отображение пункта главного меню. 
 Опять же приметивно, но на первых порах пойдет.

####  Bar.vue
Компонент bar, назначение его пока не придумал.

####  Files.vue
Компонент отображающий список файлов полученных с сервера.

####  Foo.vue
Компонент foo, назначение его пока не придумал.

####  Home.vue
Компонент стартовой страницы.
 